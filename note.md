# 全体を通して

- 方針は固めすぎない
- 実装しすぎない
- 思い込みをなくす
- 少しずつ改善する
- 何か問題特有のヒューリスティックは必要
- ボトムアップに考える
- 問題の観察を丁寧にする
- 貪欲の質を上げる

# 考察メモ

## 1/28

- スコアは最短距離の増加量（の期待値）

    $
    \displaystyle f_k = \frac{\sum_{i \neq j} (d_k(i, j) - d(i, j))}{N (N-1)}
    $

    - 最短距離の総和と一緒

- 連結でないとでかいペナルティ
    - 連結であることは前提
- 平面グラフの性質を勉強する必要がありそう
    - https://xuzijian629.hatenablog.com/entry/2019/12/14/163726
    - Separator定理?
    - 最短路問題が$O(n \sqrt{\log r})$で解けるらしい
- ドロネー三角形分割

- 全ての頂点対距離を計算するのは$O(N ^ 3)$であり、現実的でない
    - いくつかサンプリングする?
- 連結かどうかの判定は$O(N)$

- 一つの頂点に対して2つ以上封鎖する道路ができると、回り道をする必要が出てくる
    - 嘘っぽい
- 封鎖する道路に対して、効率的な迂回路が存在するときはそこまで影響がない
    - 効率的な通路が複数存在する場合は、スコアに影響しにくい

- 全ての道路は必ず1回封鎖するので、封鎖する道路の組み合わせを最適化する問題

- 全体の最適化が結構難しい
    - 全ての頂点が始点なので、改善しているかどうかの判断が間違っている可能性もある
- ちなみに、辺を切り替えた時のスコアの差分計算は可能か
    - 無理そう

- 平面グラフなので、座標を使う方針が筋が良さそう
    - 封鎖している道路の反対側にある頂点には行きづらくなる
- 始点を一つに定めると、必要な道路は木になる

- まずは、賢い貪欲を考えよう
    - 焼きなましでたくさん時間をかけて解を作る
        - スコアの遷移も記録しておきたい
    - ビジュアライズして、良い解の性質を見つける
    - 小さいケースで考えた方が良さそう
- 賢い貪欲の初期解を作って、最後に焼く方針になりそう
- なぜ直線が良いのか
    - 直線で工事すると、最短路を何個も潰すことが少なくなる
    - 同じ頂点から出ている、角度が近い辺を潰すと良くない
- 最短距離の評価は局所に分割して計算したい
- 他の方針
    - 1点からダイクストラして、不要な辺を数える
    - 最小全域木を作る

### 良さそうな性質

- 辺の角度
- 最短路に使われている回数
- 封鎖する道路同士の近さ
- 道路の長さ

## 1/29

- 頂点対の最短路をいくつか作って、その工事日時を切り替える
    - `create_initial_state3`
    - 微妙
- `create_initial_state4`
    - 辺同士の角度は、スコアにかなり比例する
    - `out/create_initial_state_progress_20min.png`

- 初期解パートの改善
    - 辺同士の角度のスコアの付け方
        - 2乗で評価した方が良さそう
        - `(sim + 0.7) ^ 3`とか
        - 同じ色だけを考慮しているけど、それで良いか
            - 良さそうだけど。。
    - 繋がっている辺同士の長さも考慮できると良さそう
        - 何が良いかはわからないけど
    - 日数が少ない場合が難しい
- 最適化パートの改善
    - 選ぶ日を一様ランダムでなくする
        - 同じ頂点から出ている辺と同じ日が出やすくする
        - 工事が少ない日ほど選ばれる
    - 重要な辺を重点的に探索する
        - 橋とか
    - 最短距離の評価を局所に分割して計算する
    - 評価の高速化
        - 1箇所しか更新してないのに、全て計算し直しているのは勿体無い

- 最短路を丸ごと入れ替える近傍
- 連結じゃなかった時の対策を入れておく必要はある
    - 日にちごとに連結成分を見て、橋になっている辺の色を変える

```
commit: 370f1ef09184f711d8b8b73e254a16e2a7e7f348
create_initial_state
ave: 14,596,936.61
    average_score
5    49541238 47401070   40958465  38981308 38600629
8    34788380 32119030   28485502  27499410 26698230
11   16592265 14540240   13552961  12825062 12556232
14   14205811 12413420   11448499  11180182 10878052
17   22685105 10043370    9209095   8986244  8876302
20    8500801  7022877    6533730   6496255  6423530
23    9955359  8576474    8037570   7927438  7743849
26    9017549  7853826    7382003   7221247  7044526
29    6845742  5771653    5448367   5368525  5273163
```

- この道路が使えないなら、この道路も使わなくても良い
- なんか平行な道路をたくさん封鎖しているとスコアが良い気がする

- サブグラフを作って、その中を最適化
    - 端の頂点からの距離の最適化

- distが計算されているのを使えない?
    - 消す時
        - それが最短路に含まれていなければ影響はない
            - 半分くらいはこれ
        - 含まれている場合は再計算が必要
            - 削除された辺の子孫だけ再計算
                - 嘘、他の頂点から最短路が伸びることが全然ある
                - TODO: 工夫できそう
                - 一時的にペナルティを子孫に加える、一定間隔で再計算する、など
            - 距離が近くなることはない
    - 追加する時
        - 頂点を結ぶ
        - 辺の端点のどちらかの距離が更新されれば、可能な限り更新し続ける
            - 距離が遠くなることはない
    - 本当に速い?
    - 木を維持するために、使えない辺を通る必要があるかもしれない
    - 木のサイズを持っておくといいことがあるかも

- Vecの使い回しをしている箇所を探す