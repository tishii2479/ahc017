# 全体を通して

- 方針は固めすぎない
- 実装しすぎない
- 思い込みをなくす
- 少しずつ改善する
- 何か問題特有のヒューリスティックは必要
- ボトムアップに考える
- 問題の観察を丁寧にする
- 貪欲の質を上げる

# 考察メモ

## 1/28

- スコアは最短距離の増加量（の期待値）

    $
    \displaystyle f_k = \frac{\sum_{i \neq j} (d_k(i, j) - d(i, j))}{N (N-1)}
    $

    - 最短距離の総和と一緒

- 連結でないとでかいペナルティ
    - 連結であることは前提
- 平面グラフの性質を勉強する必要がありそう
    - https://xuzijian629.hatenablog.com/entry/2019/12/14/163726
    - Separator定理?
    - 最短路問題が$O(n \sqrt{\log r})$で解けるらしい
- ドロネー三角形分割

- 全ての頂点対距離を計算するのは$O(N ^ 3)$であり、現実的でない
    - いくつかサンプリングする?
- 連結かどうかの判定は$O(N)$

- 一つの頂点に対して2つ以上封鎖する道路ができると、回り道をする必要が出てくる
    - 嘘っぽい
- 封鎖する道路に対して、効率的な迂回路が存在するときはそこまで影響がない
    - 効率的な通路が複数存在する場合は、スコアに影響しにくい

- 全ての道路は必ず1回封鎖するので、封鎖する道路の組み合わせを最適化する問題

- 全体の最適化が結構難しい
    - 全ての頂点が始点なので、改善しているかどうかの判断が間違っている可能性もある
- ちなみに、辺を切り替えた時のスコアの差分計算は可能か
    - 無理そう

- 平面グラフなので、座標を使う方針が筋が良さそう
    - 封鎖している道路の反対側にある頂点には行きづらくなる
- 始点を一つに定めると、必要な道路は木になる

- まずは、賢い貪欲を考えよう
    - 焼きなましでたくさん時間をかけて解を作る
        - スコアの遷移も記録しておきたい
    - ビジュアライズして、良い解の性質を見つける
    - 小さいケースで考えた方が良さそう
- 賢い貪欲の初期解を作って、最後に焼く方針になりそう
- なぜ直線が良いのか
    - 直線で工事すると、最短路を何個も潰すことが少なくなる
    - 同じ頂点から出ている、角度が近い辺を潰すと良くない
- 最短距離の評価は局所に分割して計算したい
- 他の方針
    - 1点からダイクストラして、不要な辺を数える
    - 最小全域木を作る

### 良さそうな性質

- 辺の角度
- 最短路に使われている回数
- 封鎖する道路同士の近さ
- 道路の長さ

## 1/29

- 頂点対の最短路をいくつか作って、その工事日時を切り替える
    - `create_initial_state3`
    - 微妙
- `create_initial_state4`
    - 辺同士の角度は、スコアにかなり比例する
    - `out/create_initial_state_progress_20min.png`

- 初期解パートの改善
    - 辺同士の角度のスコアの付け方
        - 2乗で評価した方が良さそう
        - `(sim + 0.7) ^ 3`とか
        - 同じ色だけを考慮しているけど、それで良いか
            - 良さそうだけど。。
    - 繋がっている辺同士の長さも考慮できると良さそう
        - 何が良いかはわからないけど
    - 日数が少ない場合が難しい
- 最適化パートの改善
    - 選ぶ日を一様ランダムでなくする
        - 同じ頂点から出ている辺と同じ日が出やすくする
        - 工事が少ない日ほど選ばれる
    - 重要な辺を重点的に探索する
        - 橋とか
    - 最短距離の評価を局所に分割して計算する
    - 評価の高速化
        - 1箇所しか更新してないのに、全て計算し直しているのは勿体無い

- 最短路を丸ごと入れ替える近傍
- 連結じゃなかった時の対策を入れておく必要はある
    - 日にちごとに連結成分を見て、橋になっている辺の色を変える

- この道路が使えないなら、この道路も使わなくても良い
- なんか平行な道路をたくさん封鎖しているとスコアが良い気がする

- サブグラフを作って、その中を最適化
    - 端の頂点からの距離の最適化

- distが計算されているのを使えない?
    - 消す時
        - それが最短路に含まれていなければ影響はない
            - 半分くらいはこれ
        - 含まれている場合は再計算が必要
            - 削除された辺の子孫だけ再計算
                - 嘘、他の頂点から最短路が伸びることが全然ある
                - 子ノードをどこかにくっつけて、近似解を作る
            - 距離が近くなることはない
    - 追加する時
        - 頂点を結ぶ
        - 辺の端点のどちらかの距離が更新されれば、可能な限り更新し続ける
            - 距離が遠くなることはない
    - 本当に速い?
    - 木を維持するために、使えない辺を通る必要があるかもしれない
    - 木のサイズを持っておくといいことがあるかも
        - どれくらい増えるかが計算できそう

## 1/30

- `Agent.add_edge, remove_edge`が逆変換になっていないので、毎回スコアの合計を計算する必要がある
    - 複数操作すると部分木が分かれるから、壊れる（多分）
    - `score_diff`を足してあげれば多分差分計算はできる

- 定期的に違う点を使うようにする?

- TODO: 途中で何回か解を保存しておく
    - スタートは全部じゃなくて、50個だけでも良い
    - 温度の冷却を少し早めに終わらせる

- 焼きなましの改善
    - 近傍の改善
        - 隣り合う同じ工事日の辺を違う工事日に変える
        - 重要な辺を重点的に探索する
            - 橋とか
    - 近傍の追加
        - 巨大近傍
    - 高速化
        - 評価の高速化
            - これ以上無理?
        - 10倍くらい高速化したい
        - 遅延評価
            - 更新する前に、簡単に評価する
                - 追加
                    - 追加することによって、どっちかの距離が小さくなるなら
                        - （大体）距離の差 * 部分木のサイズ
                            - 親も更新されるかもしれないけど、一旦は無視
                            - 距離がめっちゃ更新されるなら、親も更新されやすいので、それを考慮するのはあり
                - 削除
                    - 削除することによって、最短路が無くなるなら
                    - 部分木の根に近い頂点を探して、そこと繋いだ時の差分
                        - （大体）距離の差 * 部分木のサイズ
                        - 部分木が分かれた時は、もう少し小さくなる
                        - 隣接している頂点だけでなく、もう少し探してみる
                - 部分木のサイズを持っておく
            - 採用が決まったら、更新する
            - 2倍くらい高速化されそう?

- 全てのagentは、最短路に使っている道を記憶できる
    - 道ごとに、どれくらい最短路に使われているかカウントできる

- 全体最適化を考えると、1日で最短路によく使われる道を工事しておくと、他の日はそこを使えるので嬉しい

## 1/31

### 辺の削除

1. 削除する辺の子を取得する
2. 子からdfs
    1. 通った頂点と辺を持つ
    2. 深さ3まで
    3. 連結できる頂点が見つかったら、スコアを計算する
        1. 部分木のサイズ * 差分
        2. ロールバックして、前の部分木のサイズを引く
        3. 部分木が分かれる可能性があるので、厳密ではない
            - 影響は大きく見積もられる
3. スコアの減少が一番少ない辺を根にして、その子の子孫を更新する
    1. その前に、par_edgeの更新をする
    2. 元の部分木に含まれている辺を通る
    3. 終わったら、サイズを更新する

### 辺の追加

1. 追加する辺で、距離が縮まる頂点を取得する
2. 部分木のサイズ * 差分
    - 親も更新される可能性があるので、厳密ではない
        - 影響は小さく見積もられる
    - 根に向かっていくつか遡った頂点の部分木が更新されるので、それで多分厳密に計算できる
    - それか、愚直に計算
3. 愚直に更新する
    - 親も更新すると、サイズの更新は親に向かって更新する必要がある

- 工事する道路の連結成分ごとに、日にちを焼く

## 2/3

- 削除の高速化
- 連結成分ごとに焼く
    - branch: change-construction
        - あまり効果なし
- 遅延評価

- 基点に選ぶ点を工夫する
    - 場所を選び直す
    - 場所を増やす
    - 場所を変える
    - 真ん中の重みを大きくする?

- 最適な基点の数は、Dの大きさに依存する
    - 限界まで高速化して、nを最適化する

- 工事する辺の数をなるべく均等にする
    - 意味なし

```
     baseline  submit1       4s      40s    estim estim10s  1e6,1e3
5    49541238 38480816 36793275 34838801 33802122 33233220 33253781
8    34788380 26566797 25289072 24017787 23604820 23221684 23043438
11   16592265 12362478 11423818 10888328 10978855 10748257 10795367
14   14205811 10570912  9895251  9526441  9590682  9389688  9425982
17   22685105  8509219  7889357  7583952  7596239  7402651  7536143
20    8500801  5959257  5673136  5347932  5458562  5298630  5495610
23    9955359  7208798  6790425  6526283  6699834  6479009  6650562
26    9017549  6545614  6151958  5907149  5977136  5796703  5916755
29    6845742  4792797  4559804  4344325  4422711  4314746  4419850
```

- 辺の削除の高速化
    - 辺をとるときに、うまく再連結する辺が見つからない時は中断する
    - 厳密な辺の削除を考える
- 冷却を早くする
    - 意味なし

## 2/4

- 距離も遅延評価する
    - 距離を求めるときは、親に向かって通る辺の距離を足す
    - 遅くなった
        - branch: lazy_eval dist

```
      submit2     100s   sel0.8 wise-sel  1e6-1e3  1e6-1e2     n=10     n=12
2.0  59627840 55795005 58062236 57709954 60439224 58216233 57432045 60789870
3.0  31515755 30557031 31684818 31502013 31306074 31404134 31487326 31448949
4.0  13027945 12543253 12923648 13023372 12891515 12886260 12907223 12904813
5.0   8069697  7752090  8024085  8059329  7964355  7979277  7962279  8027510
6.0   4940330  4721558  4911868  4926304  4872296  4857565  4835494  4881639
7.0   3295864  3130509  3249068  3273899  3240904  3227577  3212444  3237586
8.0   2212424  2080777  2166316  2164027  2173652  2138087  2135828  2153503
9.0   1736084  1594887  1687299  1712891  1700907  1672944  1652446  1671840
```

- これ以上の高速化は厳しいかも
- 近傍の工夫
    - 選ぶ辺を工夫する
        - 距離が大きく伸びている頂点を優先的に選ぶ
            - agentをランダムに選ぶ
                - 工事がない場合の距離と比較して、大きく距離が増えている頂点を選ぶ
                    - 5個頂点をランダムに選び、その中で最も距離が増えている頂点を選ぶ
                - その頂点から出ている辺を一つ選んで、工事日を別の日に変えてみる
            - 工事日をランダムに選ぶ
                - 全てのagentの中で、距離が増えている頂点を選ぶ
                    - 5個頂点をランダムに選び、その中で最も距離が増えている頂点を選ぶ
                - その頂点から出ている辺を一つ選んで、工事日を別の日に変えてみる
    - 選ぶ工事日を工夫する
        - 頂点に繋がっている工事を採用する

## 2/5

- 近傍の工夫、うまくいかず
    - なぜだろう
- swap、連結成分ごとに動かす
    - 複数動かすと壊れるため難しい

```
1000case
      submit3    8->16  r:3-500 ir:0-500 ir:3-5-8 ir:3-500-8-16
2.0  51296250 51444497 51417071 53953370 50855805      51982529
3.0  27256043 27142716 26986710 27901602 27050016      26983091
4.0  13688506 13624724 13582003 14102502 13629924      13542095
5.0   7762993  7728170  7715169  7974305  7726332       7680635
6.0   4780305  4738323  4729161  4917743  4754842       4712003
7.0   3171683  3143564  3133526  3270750  3154986       3130524
8.0   2296251  2276681  2266697  2375447  2284950       2258335
9.0   1781072  1763552  1756861  1836142  1763703       1745083

temperature
      1e6-1e2  1e6-1e3 1e6-1e3r
2.0  51982529 51544257 51702881
3.0  26983091 26830720 26929094
4.0  13542095 13501798 13518833
5.0   7680635  7672606  7672614
6.0   4712003  4722387  4712089
7.0   3130524  3138387  3120390
8.0   2258335  2281766  2262383
9.0   1745083  1774819  1750299

update
       0.0301   0.0501   0.1001   0.2001
2.0  50728509 51310920 51544257 51929235
3.0  26701520 26757539 26830720 26927828
4.0  13436070 13460615 13501798 13577168
5.0   7650272  7646424  7672606  7709840
6.0   4696741  4690228  4712003  4743755
7.0   3109942  3109180  3130524  3145206
8.0   2248806  2247755  2258335  2276727
9.0   1734427  1740080  1745083  1763829

depth
            2        3
2.0  51166501 51893653
3.0  26735711 26981366
4.0  13453341 13596172
5.0   7651745  7727452
6.0   4691960  4759906
7.0   3108039  3165948
8.0   2250045  2294324
9.0   1740412  1775729

agent_n
            8       10
2.0  51166501 51256979
3.0  26735711 26995648
4.0  13453341 13625984
5.0   7651745  7735762
6.0   4691960  4759897
7.0   3108039  3156294
8.0   2250045  2286512
9.0   1740412  1768784

r         400      200      350      300
2.0  51964012 51144207 50949638 51929235
3.0  27016575 27117859 26973044 26927828
4.0  13588353 13634694 13568547 13577168
5.0   7710705  7752942  7721067  7709840
6.0   4744174  4769876  4744216  4743755
7.0   3143752  3169270  3142382  3145206
8.0   2272951  2294318  2275150  2276727
9.0   1760759  1769893  1762223  1763829

      submit3  submit4
2.0  51296250 51310920
3.0  27256043 26757539
4.0  13688506 13460615
5.0   7762993  7646424
6.0   4780305  4690228
7.0   3171683  3109180
8.0   2296251  2247755
9.0   1781072  1740080

     350-0.05 300-0.05 300-0.03 333-0.04
2.0  51493649 51310920 50728509 50507879
3.0  26778340 26757539 26701520 26689009
4.0  13449174 13460615 13436070 13470580
5.0   7642146  7646424  7650272  7640049
6.0   4694724  4690228  4696741  4691546
7.0   3108204  3109180  3109942  3106383
8.0   2248592  2247755  2248806  2247351
9.0   1740628  1740080  1734427  1738863
```

- 基点の工夫
    - r=300-500, 0~:8, 0.8~:16
- 最後に16に増やすかどうか
    - 足した方が良い
- 温度
    - 1e6
    - if rank <= 6. { 1e3 } else { 1e2 }
- UPDATE_INTERVAL
    - 0.0401
- 深さ
    - 2
- agent_n
    - 8
- r
    - 333