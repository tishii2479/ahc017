# 全体を通して

- 方針は固めすぎない
- 実装しすぎない
- 思い込みをなくす
- 少しずつ改善する
- 何か問題特有のヒューリスティックは必要
- ボトムアップに考える
- 問題の観察を丁寧にする
- 貪欲の質を上げる

# 考察メモ

## 1/28

- スコアは最短距離の増加量（の期待値）

    $
    \displaystyle f_k = \frac{\sum_{i \neq j} (d_k(i, j) - d(i, j))}{N (N-1)}
    $

    - 最短距離の総和と一緒

- 連結でないとでかいペナルティ
    - 連結であることは前提
- 平面グラフの性質を勉強する必要がありそう
    - https://xuzijian629.hatenablog.com/entry/2019/12/14/163726
    - Separator定理?
    - 最短路問題が$O(n \sqrt{\log r})$で解けるらしい
- ドロネー三角形分割

- 全ての頂点対距離を計算するのは$O(N ^ 3)$であり、現実的でない
    - いくつかサンプリングする?
- 連結かどうかの判定は$O(N)$

- 一つの頂点に対して2つ以上封鎖する道路ができると、回り道をする必要が出てくる
    - 嘘っぽい
- 封鎖する道路に対して、効率的な迂回路が存在するときはそこまで影響がない
    - 効率的な通路が複数存在する場合は、スコアに影響しにくい

- 全ての道路は必ず1回封鎖するので、封鎖する道路の組み合わせを最適化する問題

- 全体の最適化が結構難しい
    - 全ての頂点が始点なので、改善しているかどうかの判断が間違っている可能性もある
- ちなみに、辺を切り替えた時のスコアの差分計算は可能か
    - 無理そう

- 平面グラフなので、座標を使う方針が筋が良さそう
    - 封鎖している道路の反対側にある頂点には行きづらくなる
- 始点を一つに定めると、必要な道路は木になる

- まずは、賢い貪欲を考えよう
    - 焼きなましでたくさん時間をかけて解を作る
        - スコアの遷移も記録しておきたい
    - ビジュアライズして、良い解の性質を見つける
    - 小さいケースで考えた方が良さそう
- 賢い貪欲の初期解を作って、最後に焼く方針になりそう
- なぜ直線が良いのか
    - 直線で工事すると、最短路を何個も潰すことが少なくなる
    - 同じ頂点から出ている、角度が近い辺を潰すと良くない
- 最短距離の評価は局所に分割して計算したい
- 他の方針
    - 1点からダイクストラして、不要な辺を数える
    - 最小全域木を作る

### 良さそうな性質

- 辺の角度
- 最短路に使われている回数
- 封鎖する道路同士の近さ
- 道路の長さ

## 1/29

- 頂点対の最短路をいくつか作って、その工事日時を切り替える
    - `create_initial_state3`
    - 微妙
- `create_initial_state4`
    - 辺同士の角度は、スコアにかなり比例する
    - `out/create_initial_state_progress_20min.png`

- 初期解パートの改善
    - 辺同士の角度のスコアの付け方
        - 2乗で評価した方が良さそう
        - `(sim + 0.7) ^ 3`とか
        - 同じ色だけを考慮しているけど、それで良いか
            - 良さそうだけど。。
    - 繋がっている辺同士の長さも考慮できると良さそう
        - 何が良いかはわからないけど
    - 日数が少ない場合が難しい
- 最適化パートの改善
    - 選ぶ日を一様ランダムでなくする
        - 同じ頂点から出ている辺と同じ日が出やすくする
        - 工事が少ない日ほど選ばれる
    - 重要な辺を重点的に探索する
        - 橋とか
    - 最短距離の評価を局所に分割して計算する
    - 評価の高速化
        - 1箇所しか更新してないのに、全て計算し直しているのは勿体無い

- 最短路を丸ごと入れ替える近傍
- 連結じゃなかった時の対策を入れておく必要はある
    - 日にちごとに連結成分を見て、橋になっている辺の色を変える

- この道路が使えないなら、この道路も使わなくても良い
- なんか平行な道路をたくさん封鎖しているとスコアが良い気がする

- サブグラフを作って、その中を最適化
    - 端の頂点からの距離の最適化

- distが計算されているのを使えない?
    - 消す時
        - それが最短路に含まれていなければ影響はない
            - 半分くらいはこれ
        - 含まれている場合は再計算が必要
            - 削除された辺の子孫だけ再計算
                - 嘘、他の頂点から最短路が伸びることが全然ある
                - 子ノードをどこかにくっつけて、近似解を作る
            - 距離が近くなることはない
    - 追加する時
        - 頂点を結ぶ
        - 辺の端点のどちらかの距離が更新されれば、可能な限り更新し続ける
            - 距離が遠くなることはない
    - 本当に速い?
    - 木を維持するために、使えない辺を通る必要があるかもしれない
    - 木のサイズを持っておくといいことがあるかも
        - どれくらい増えるかが計算できそう

## 1/30

- `Agent.add_edge, remove_edge`が逆変換になっていないので、毎回スコアの合計を計算する必要がある
    - 複数操作すると部分木が分かれるから、壊れる（多分）
    - `score_diff`を足してあげれば多分差分計算はできる

- 定期的に違う点を使うようにする?

- TODO: 途中で何回か解を保存しておく
    - スタートは全部じゃなくて、50個だけでも良い
    - 温度の冷却を少し早めに終わらせる

- 焼きなましの改善
    - 近傍の改善
        - 隣り合う同じ工事日の辺を違う工事日に変える
        - 重要な辺を重点的に探索する
            - 橋とか
    - 近傍の追加
        - 巨大近傍
    - 高速化
        - 評価の高速化
            - これ以上無理?
        - 10倍くらい高速化したい
        - 遅延評価
            - 更新する前に、簡単に評価する
                - 追加
                    - 追加することによって、どっちかの距離が小さくなるなら
                        - （大体）距離の差 * 部分木のサイズ
                            - 親も更新されるかもしれないけど、一旦は無視
                            - 距離がめっちゃ更新されるなら、親も更新されやすいので、それを考慮するのはあり
                - 削除
                    - 削除することによって、最短路が無くなるなら
                    - 部分木の根に近い頂点を探して、そこと繋いだ時の差分
                        - （大体）距離の差 * 部分木のサイズ
                        - 部分木が分かれた時は、もう少し小さくなる
                        - 隣接している頂点だけでなく、もう少し探してみる
                - 部分木のサイズを持っておく
            - 採用が決まったら、更新する
            - 2倍くらい高速化されそう?

- 全てのagentは、最短路に使っている道を記憶できる
    - 道ごとに、どれくらい最短路に使われているかカウントできる

- 全体最適化を考えると、1日で最短路によく使われる道を工事しておくと、他の日はそこを使えるので嬉しい

## 1/31

### 辺の削除

1. 削除する辺の子を取得する
2. 子からdfs
    1. 通った頂点と辺を持つ
    2. 深さ3まで
    3. 連結できる頂点が見つかったら、スコアを計算する
        1. 部分木のサイズ * 差分
        2. ロールバックして、前の部分木のサイズを引く
        3. 部分木が分かれる可能性があるので、厳密ではない
            - 影響は大きく見積もられる
3. スコアの減少が一番少ない辺を根にして、その子の子孫を更新する
    1. その前に、par_edgeの更新をする
    2. 元の部分木に含まれている辺を通る
    3. 終わったら、サイズを更新する

### 辺の追加

1. 追加する辺で、距離が縮まる頂点を取得する
2. 部分木のサイズ * 差分
    - 親も更新される可能性があるので、厳密ではない
        - 影響は小さく見積もられる
    - 根に向かっていくつか遡った頂点の部分木が更新されるので、それで多分厳密に計算できる
    - それか、愚直に計算
3. 愚直に更新する
    - 親も更新すると、サイズの更新は親に向かって更新する必要がある

- 工事する道路の連結成分ごとに、日にちを焼く

## 2/3

- 削除の高速化
- 連結成分ごとに焼く
    - branch: change-construction
        - あまり効果なし
- 遅延評価

- 基点に選ぶ点を工夫する
    - 場所を選び直す
    - 場所を増やす
    - 場所を変える
    - 真ん中の重みを大きくする?

- 最適な基点の数は、Dの大きさに依存する
    - 限界まで高速化して、nを最適化する

- 工事する辺の数をなるべく均等にする
    - 意味なし

```
     baseline  submit1       4s      40s    estim estim10s  1e6,1e3
5    49541238 38480816 36793275 34838801 33802122 33233220 33253781
8    34788380 26566797 25289072 24017787 23604820 23221684 23043438
11   16592265 12362478 11423818 10888328 10978855 10748257 10795367
14   14205811 10570912  9895251  9526441  9590682  9389688  9425982
17   22685105  8509219  7889357  7583952  7596239  7402651  7536143
20    8500801  5959257  5673136  5347932  5458562  5298630  5495610
23    9955359  7208798  6790425  6526283  6699834  6479009  6650562
26    9017549  6545614  6151958  5907149  5977136  5796703  5916755
29    6845742  4792797  4559804  4344325  4422711  4314746  4419850
```

- 辺の削除の高速化
    - 辺をとるときに、うまく再連結する辺が見つからない時は中断する
    - 厳密な辺の削除を考える
- 冷却を早くする
    - 意味なし

## 2/4

- 距離も遅延評価する
    - 距離を求めるときは、親に向かって通る辺の距離を足す
    - 遅くなった
        - branch: lazy_eval dist

```
      submit2     100s   sel0.8
2.0  59627840 55795005 58062236
3.0  31515755 30557031 31684818
4.0  13027945 12543253 12923648
5.0   8069697  7752090  8024085
6.0   4940330  4721558  4911868
7.0   3295864  3130509  3249068
8.0   2212424  2080777  2166316
9.0   1736084  1594887  1687299
```

- これ以上の高速化は厳しいかも
- 近傍の工夫
    - 選ぶ辺を工夫する
        - 距離が大きく伸びている頂点を優先的に選ぶ
        - 工事がない場合の距離と比較して、大きく距離が増えている頂点を選ぶ
        - その頂点から出ている辺を一つ選んで、工事日を別の日に変える
    - 選ぶ工事日を工夫する
        - 頂点に繋がっている工事を採用する