# 全体を通して

- 方針は固めすぎない
- 実装しすぎない
- 思い込みをなくす
- 少しずつ改善する
- 何か問題特有のヒューリスティックは必要
- ボトムアップに考える
- 問題の観察を丁寧にする
- 貪欲の質を上げる

# 考察メモ

## 1/28

- スコアは最短距離の増加量（の期待値）

    $
    \displaystyle f_k = \frac{\sum_{i \neq j} (d_k(i, j) - d(i, j))}{N (N-1)}
    $

    - 最短距離の総和と一緒

- 連結でないとでかいペナルティ
    - 連結であることは前提
- 平面グラフの性質を勉強する必要がありそう
    - https://xuzijian629.hatenablog.com/entry/2019/12/14/163726
    - Separator定理?
    - 最短路問題が$O(n \sqrt{\log r})$で解けるらしい
- ドロネー三角形分割

- 全ての頂点対距離を計算するのは$O(N ^ 3)$であり、現実的でない
    - いくつかサンプリングする?
- 連結かどうかの判定は$O(N)$

- 一つの頂点に対して2つ以上封鎖する道路ができると、回り道をする必要が出てくる
    - 嘘っぽい
- 封鎖する道路に対して、効率的な迂回路が存在するときはそこまで影響がない
    - 効率的な通路が複数存在する場合は、スコアに影響しにくい

- 全ての道路は必ず1回封鎖するので、封鎖する道路の組み合わせを最適化する問題

- 全体の最適化が結構難しい
    - 全ての頂点が始点なので、改善しているかどうかの判断が間違っている可能性もある
- ちなみに、辺を切り替えた時のスコアの差分計算は可能か
    - 無理そう

- 平面グラフなので、座標を使う方針が筋が良さそう
    - 封鎖している道路の反対側にある頂点には行きづらくなる
- 始点を一つに定めると、必要な道路は木になる

- まずは、賢い貪欲を考えよう
    - 焼きなましでたくさん時間をかけて解を作る
        - スコアの遷移も記録しておきたい
    - ビジュアライズして、良い解の性質を見つける
    - 小さいケースで考えた方が良さそう
- 賢い貪欲の初期解を作って、最後に焼く方針になりそう
- なぜ直線が良いのか
    - 直線で工事すると、最短路を何個も潰すことが少なくなる
    - 同じ頂点から出ている、角度が近い辺を潰すと良くない
- 最短距離の評価は局所に分割して計算したい
- 他の方針
    - 1点からダイクストラして、不要な辺を数える
    - 最小全域木を作る

### 良さそうな性質

- 辺の角度
- 最短路に使われている回数
- 封鎖する道路同士の近さ
- 道路の長さ

## 1/29

- 頂点対の最短路をいくつか作って、その工事日時を切り替える
    - `create_initial_state3`
    - 微妙
- `create_initial_state4`
    - 辺同士の角度は、スコアにかなり比例する
    - `out/create_initial_state_progress_20min.png`

- 初期解パートの改善
    - 辺同士の角度のスコアの付け方
        - 2乗で評価した方が良さそう
        - `(sim + 0.7) ^ 3`とか
        - 同じ色だけを考慮しているけど、それで良いか
            - 良さそうだけど。。
    - 繋がっている辺同士の長さも考慮できると良さそう
        - 何が良いかはわからないけど
    - 日数が少ない場合が難しい
- 最適化パートの改善
    - 選ぶ日を一様ランダムでなくする
        - 同じ頂点から出ている辺と同じ日が出やすくする
        - 工事が少ない日ほど選ばれる
    - 重要な辺を重点的に探索する
        - 橋とか
    - 最短距離の評価を局所に分割して計算する
    - 評価の高速化
        - 1箇所しか更新してないのに、全て計算し直しているのは勿体無い

- 最短路を丸ごと入れ替える近傍
- 連結じゃなかった時の対策を入れておく必要はある
    - 日にちごとに連結成分を見て、橋になっている辺の色を変える

```
     baseline   create     long   random   create   anneal l-anneal  submit1   faster
5    49541238 38600629 35811386 38293359 37960445 36905923 35662259 38480816 36438646
8    34788380 26698230 25041068 26291495 26305715 25890437 25426969 26566797 25554892
11   16592265 12556232 11907457 12089208 12292775 12248384 11771071 12362478 11683485
14   14205811 10878052 10402241 10591380 10651538 10567838 10251324 10570912 10117709
17   22685105  8876302  8270481  8382566  8411721  8366356  8072265  8509219  8101699
20    8500801  6423530  5974463  5997240  5997290  5933216  5769431  5959257  5823026
23    9955359  7743849  7032482  7249002  7236834  7186554  6934772  7208798  6843748
26    9017549  7044526  6464518  6515833  6489582  6436425  6218424  6545614  6236323
29    6845742  5273163  4752352  4805533  4782226  4763372  4603040  4792797  4641246
```

- この道路が使えないなら、この道路も使わなくても良い
- なんか平行な道路をたくさん封鎖しているとスコアが良い気がする

- サブグラフを作って、その中を最適化
    - 端の頂点からの距離の最適化

- distが計算されているのを使えない?
    - 消す時
        - それが最短路に含まれていなければ影響はない
            - 半分くらいはこれ
        - 含まれている場合は再計算が必要
            - 削除された辺の子孫だけ再計算
                - 嘘、他の頂点から最短路が伸びることが全然ある
                - 子ノードをどこかにくっつけて、近似解を作る
            - 距離が近くなることはない
    - 追加する時
        - 頂点を結ぶ
        - 辺の端点のどちらかの距離が更新されれば、可能な限り更新し続ける
            - 距離が遠くなることはない
    - 本当に速い?
    - 木を維持するために、使えない辺を通る必要があるかもしれない
    - 木のサイズを持っておくといいことがあるかも
        - どれくらい増えるかが計算できそう

## 1/30

- `Agent.add_edge, remove_edge`が逆変換になっていないので、毎回スコアの合計を計算する必要がある
    - 複数操作すると部分木が分かれるから、壊れる（多分）
    - `score_diff`を足してあげれば多分差分計算はできる

- 定期的に違う点を使うようにする?

- TODO: 途中で何回か解を保存しておく

- 焼きなましの改善
    - 近傍の改善
        - 隣り合う同じ工事日の辺を違う工事日に変える
        - 重要な辺を重点的に探索する
            - 橋とか
    - 近傍の追加
        - 巨大近傍
    - 高速化
        - 評価の高速化
            - これ以上無理?
        - 10倍くらい高速化したい
        - 遅延評価
            - 更新する前に、簡単に評価する
                - 追加
                    - 追加することによって、どっちかの距離が小さくなるなら
                        - （大体）距離の差 * 部分木のサイズ
                            - 親も更新されるかもしれないけど、一旦は無視
                            - 距離がめっちゃ更新されるなら、親も更新されやすいので、それを考慮するのはあり
                - 削除
                    - 削除することによって、最短路が無くなるなら
                    - 部分木の根に近い頂点を探して、そこと繋いだ時の差分
                        - （大体）距離の差 * 部分木のサイズ
                        - 部分木が分かれた時は、もう少し小さくなる
                        - 隣接している頂点だけでなく、もう少し探してみる
                - 部分木のサイズを持っておく
            - 採用が決まったら、更新する
            - 2倍くらい高速化されそう?

- 全てのagentは、最短路に使っている道を記憶できる
    - 道ごとに、どれくらい最短路に使われているかカウントできる

- 全体最適化を考えると、1日で最短路によく使われる道を工事しておくと、他の日はそこを使えるので嬉しい

## 1/31

### 辺の削除

1. 削除する辺の子を取得する
2. 子からdfs
    1. 通った頂点と辺を持つ
    2. 深さ3まで
    3. 連結できる頂点が見つかったら、スコアを計算する
        1. 部分木のサイズ * 差分
        2. ロールバックして、前の部分木のサイズを引く
3. スコアの減少が一番少ない辺を根にして、その子の子孫を更新する
    1. その前に、par_edgeの更新をする
    2. 元の部分木に含まれている辺を通る
    3. 終わったら、サイズを更新する

### 辺の追加

1. 追加する辺で、距離が縮まる頂点を取得する
2. 部分木のサイズ * 差分
    1. or 愚直に計算

- 工事する道路の連結成分ごとに、日にちを焼く

## 2/3

- 削除の高速化
- 連結成分ごとに焼く
- 遅延評価

- 基点に選ぶ点を工夫する
    - 場所を選び直す
    - 場所を増やす
    - 場所を変える

- 辺をとるときに、うまく再連結する辺が見つからない時は中断する